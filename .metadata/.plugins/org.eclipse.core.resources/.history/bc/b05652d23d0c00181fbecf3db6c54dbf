package local_search;

import java.util.ArrayList;
import java.util.Random;

import problem.Problem;
import problem.State;
import search.IResultObject;
import search.LocalSearch;

public class GeneticAlgorithmSearch extends LocalSearch {

	public GeneticAlgorithmSearch(ObjectiveFunction fun, StateBitStreamConversion stateToBitStream, int populationSize, int mutateProbability, int fitnessGoal, int maxGenerations) {
		super(fun);
		this.stateToBitStream = stateToBitStream;
		this.populationSize = populationSize;
		this.mutateProbability = mutateProbability;
		this.fitnessGoal = fitnessGoal;
		this.maxGenerations = maxGenerations;
	}

	public IResultObject execute(Problem problem) {
		
		// --- INITIALIZATION --- //
		Population population = new Population(populationSize);
		for (int i = 0; i < populationSize; i ++) {
			population.addIndividual(new Individual(problem.getInitialState()));
		}
		
		int generations = 0;
		while (population.fittestIndividual.fitnessScore < fitnessGoal && generations < maxGenerations) {
			Population newPopulation = new Population(populationSize);
			for (int i = 0; i < populationSize; i ++) {
				State parent1 = getParent(population, populationRankings, populationRankingsSum);
				State parent2 = getParent(population, populationRankings, populationRankingsSum);
				State child = breed(parent1, parent2);
				child = mutate(child);
				newPopulation[i] = child;
				newPopulationRankings[i] = function.execute(child);
				newPopulationRankingsSum += newPopulationRankings[i];
			}
			population = newPopulation;
			populationRankings = newPopulationRankings;
			populationRankingsSum = newPopulationRankingsSum;
			generations += 1;
		}
		
		return new LocalSearchResult(population[getFittestIndividualIndex(populationRankings)]);
	}
	
	/**
	 * Gets a parent for breeding.
	 * @param population the population
	 * @param populationRankings the values for each population 
	 * @param populationRankingsSum the sum of the population rankings
	 * @return a parent state for breeding
	 */
	private State getParent(State[] population, int[] populationRankings, int populationRankingsSum) {
		int p1_rand = gen.nextInt(populationRankingsSum);
		int c = 0;
		for (int i = 0; i < populationSize; i ++) {
			c += populationRankings[i];
			if (c > p1_rand) {
				return population[i];
			}
		}
		return null;
	}
	
	/**
	 * Generates an offspring from the parents.
	 * @param p1 the first parent
	 * @param p2 the second parent
	 * @return an offspring from the parents
	 */
	private State breed(State p1, State p2) {
		String p1BitStream = stateToBitStream.getBitStream(p1);
		String p2BitStream = stateToBitStream.getBitStream(p2);
		int crossPoint = gen.nextInt(p1BitStream.length());
		return stateToBitStream.convertBitStream(p1BitStream.substring(0, crossPoint) + p2BitStream.substring(crossPoint));
	}
	
	/**
	 * Mutates an individual.
	 * @param individual the individual to mutate
	 * @return the mutated individual
	 */
	private State mutate(State individual) {
		String bitStream = stateToBitStream.getBitStream(individual);
		String newBitStream = "";
		for (int i = 0; i < bitStream.length(); i ++) {
			int bit;
			if (i != bitStream.length() - 1) {
				bit = Integer.parseInt(bitStream.substring(i, i+1));
			} else {
				bit = Integer.parseInt(bitStream.substring(i));
			}
			if (gen.nextDouble() < mutateProbability) {
				bit = (bit + 1) % 2;
			}
			newBitStream += bit;
		}
		return stateToBitStream.convertBitStream(newBitStream);
	}
	
	private class Individual {
		public Individual(State s) {
			this.s = s;
			this.fitnessScore = function.execute(s);
		}
		private State s;
		private int fitnessScore;
	}
	
	/**
	 * A Population class for the genertics algorithm
	 * @author JLepere2
	 * @date 02/07/2018
	 */
	private class Population {
		
		/**
		 * Creates a new Population.
		 * @param populationSize the population size
		 */
		public Population(int populationSize) {
			this.population = new Individual[populationSize];
			this.currentSize = 0;
			this.totalFitnessScore = 0;
			this.fittestIndividual = null;
		}
		
		/**
		 * Adds an individual to the Population.
		 * @param i the individual
		 */
		public void addIndividual(Individual i) {
			population[currentSize] = i;
			currentSize += 1;
			totalFitnessScore = i.fitnessScore;
			if (fittestIndividual == null) {
				fittestIndividual = i;
			} else {
				if (i.fitnessScore > fittestIndividual.fitnessScore) {
					fittestIndividual = i;
				}
			}
		}
		
		/**
		 * Gets an Individual for breeding giving priority to those individuals with a higher fitness function.
		 * @return an Individual for breeding.
		 */
		private Individual getIndividualForBreeding() {
			int r = gen.nextInt(totalFitnessScore);
			int c = 0;
			for (int i = 0; i < populationSize; i ++) {
				c += population[i].fitnessScore;
				if (c > r) {
					return population[i];
				}
			}
			return null;
		}
		
		private static Individual breed(Individual i1, Individual i2) {
			
		}
		
		private Individual[] population;
		private int currentSize;
		private int totalFitnessScore;
		private Individual fittestIndividual;
	}
	
	/**
	 * An interface to define state and bit stream conversion required for the genetics algorithms
	 * @author JLepere2
	 * @date 02/07/2018
	 */
	public interface StateBitStreamConversion {
		/**
		 * Converts a state to a string of bits.
		 * @param s the state
		 * @return a string of bits
		 */
		public String getBitStream(State s);
		/**
		 * Converts a string of bits to a state.
		 * @param s the string of bits
		 * @return a state
		 */
		public State convertBitStream(String s);
	}
	
	private StateBitStreamConversion stateToBitStream;
	private int populationSize;
	private int mutateProbability;
	private int fitnessGoal;
	private int maxGenerations;
	Random gen = new Random();

}
