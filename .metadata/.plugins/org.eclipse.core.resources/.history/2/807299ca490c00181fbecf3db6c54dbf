package local_search;

import java.util.Random;

import problem.Problem;
import problem.State;
import search.IResultObject;
import search.LocalSearch;

/**
 * Implementation for the Genetics Algorithm
 * @author JLepere2
 * @date 02/07/2018
 */
public class GeneticAlgorithmSearch extends LocalSearch {

	/**
	 * Creates a Genetics Algorithm object.
	 * @param fun the objective function to evaluate the states
	 * @param sbsConversion an object to convert states to bit streams and bit streams to states
	 * @param populationSize the size of the population
	 * @param mutateProbability the probability of mutation (0.0,1.0)
	 * @param fitnessGoal the fitness goal to reach
	 * @param maxGenerations the max generations
	 */
	public GeneticAlgorithmSearch(ObjectiveFunction fun, StateBitStreamConversion sbsConversion, int populationSize, double mutateProbability, int fitnessGoal, int maxGenerations) {
		super(fun);
		this.sbsConversion = sbsConversion;
		this.populationSize = populationSize;
		this.mutateProbability = mutateProbability;
		this.fitnessGoal = fitnessGoal;
		this.maxGenerations = maxGenerations;
	}

	public IResultObject execute(Problem problem) {
		
		// --- INITIALIZATION --- //
		Population population = new Population(populationSize);
		for (int i = 0; i < populationSize; i ++) {
			population.addIndividual(new Individual(problem.getInitialState()));
		}
		
		/*
		 * GENERATION LOOPS 
		 *  - Stop when a OR b
		 *     a) fittestIndividual is sufficient
		 *     b) max generations has been reached 
		 */
		int generations = 0;
		while (population.fittestIndividual.fitnessScore < fitnessGoal && generations < maxGenerations) {
			
			// -- NEW POPULATION -- //
			Population newPopulation = new Population(populationSize);
			
			// -- POPULATE NEW POPULATION -- //
			for (int i = 0; i < populationSize; i ++) {
				
				// -- GET PARENTS -- //
				Individual parent1 = population.getParent();
				Individual parent2 = population.getParent();
				
				// -- BREED PARENTS -- //
				Individual child = population.breed(parent1, parent2);
				
				// -- MUTATE CHILD -- //
				child = population.mutate(child);
				
				// -- ADD CHILD TO POPULATION -- //
				newPopulation.addIndividual(child);
			}
			
			// -- UPDATE -- //
			population = newPopulation;
			generations += 1;
		}
		
		return new LocalSearchResult(population.fittestIndividual.state);
	}
	
	/**
	 * An Individual for the population
	 * @author JLepere2
	 * @date 02/07/2018
	 */
	private class Individual {
		
		/**
		 * Creates an Individual with an internal state
		 * @param s the state
		 */
		public Individual(State s) {
			this.state = s;
			this.fitnessScore = function.execute(s);
		}
		
		private State state;
		private int fitnessScore;
	}
	
	/**
	 * A Population class for the genetics algorithm
	 * @author JLepere2
	 * @date 02/07/2018
	 */
	private class Population {
		
		/**
		 * Creates a new Population.
		 * @param populationSize the population size
		 */
		public Population(int populationSize) {
			this.population = new Individual[populationSize];
			this.currentSize = 0;
			this.totalFitnessScore = 0;
			this.fittestIndividual = null;
		}
		
		/**
		 * Adds an individual to the Population.
		 * @param i the individual
		 */
		public void addIndividual(Individual i) {
			population[currentSize] = i;
			currentSize += 1;
			totalFitnessScore = i.fitnessScore;
			if (fittestIndividual == null) {
				fittestIndividual = i;
			} else {
				if (i.fitnessScore > fittestIndividual.fitnessScore) {
					fittestIndividual = i;
				}
			}
		}
		
		/**
		 * Gets a parent Individual for breeding giving priority to those individuals with a higher fitness function.
		 * @return an Individual for breeding.
		 */
		private Individual getParent() {
			int r = gen.nextInt(totalFitnessScore);
			int c = 0;
			for (int i = 0; i < populationSize; i ++) {
				c += population[i].fitnessScore;
				if (c > r) {
					return population[i];
				}
			}
			return null;
		}
		
		/**
		 * Breeds two individuals to create a child.
		 * @param i1 the first individual
		 * @param i2 the second individual
		 * @return a child
		 */
		private Individual breed(Individual i1, Individual i2) {
			String p1BitStream = sbsConversion.getBitStream(i1.state);
			String p2BitStream = sbsConversion.getBitStream(i2.state);
			int crossPoint = gen.nextInt(p1BitStream.length());
			return new Individual(sbsConversion.convertBitStream(p1BitStream.substring(0, crossPoint) + p2BitStream.substring(crossPoint)));
		}
		
		/**
		 * Mutates an individual with some probability
		 * @param individual the individual
		 * @return a new mutated individual
		 */
		private Individual mutate(Individual individual) {
			String bitStream = sbsConversion.getBitStream(individual.state);
			String newBitStream = "";
			for (int i = 0; i < bitStream.length(); i ++) {
				int bit;
				if (i != bitStream.length() - 1) {
					bit = Integer.parseInt(bitStream.substring(i, i+1));
				} else {
					bit = Integer.parseInt(bitStream.substring(i));
				}
				if (gen.nextDouble() < mutateProbability) {
					bit = (bit + 1) % 2;
				}
				newBitStream += bit;
			}
			return new Individual(sbsConversion.convertBitStream(newBitStream));
		}
		
		private Individual[] population;
		private int currentSize;
		private int totalFitnessScore;
		private Individual fittestIndividual;
	}
	
	/**
	 * An interface to define state and bit stream conversion required for the genetics algorithms
	 * @author JLepere2
	 * @date 02/07/2018
	 */
	public interface StateBitStreamConversion {
		/**
		 * Converts a state to a string of bits.
		 * @param s the state
		 * @return a string of bits
		 */
		public String getBitStream(State s);
		/**
		 * Converts a string of bits to a state.
		 * @param s the string of bits
		 * @return a state
		 */
		public State convertBitStream(String s);
	}
	
	private StateBitStreamConversion sbsConversion;
	private int populationSize;
	private double mutateProbability;
	private int fitnessGoal;
	private int maxGenerations;
	Random gen = new Random();

}
