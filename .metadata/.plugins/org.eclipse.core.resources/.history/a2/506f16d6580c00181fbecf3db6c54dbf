import local_search.GeneticAlgorithmSearch.StateBitStreamConversion;
import problem.State;

public class NQueensStateBitStreamConverstion implements StateBitStreamConversion {

	public NQueensStateBitStreamConverstion(int n) {
		this.n = n;
		this.alwaysAcceptableBitStream = ((n & (n-1)) == 0);
	}
	
	public int[] getBitStream(State s) {
		int[] queenLocations = ((NQueensState) s).getQueenLocations();
		int maxBits = Integer.toBinaryString(n-1).length();
		int[] bitStream = new int[maxBits * n];
		for (int i = 0; i < n; i ++) {
			String bString = Integer.toBinaryString(queenLocations[i]);
			for (int e = bString.length(); e < maxBits; e ++) {
				bString = "0" + bString;
			}
			for (int j = 0; j < maxBits; j ++) {
				bitStream[i+j] = bString.charAt(j);
			}
		}
		return bitStream;
	}

	public State convertBitStream(int[] s) {
		int maxBits = Integer.toBinaryString(n-1).length();
		int[] queenLocations = new int[n];
		int numIterations = s.length/maxBits; 
		for (int i = 0; i < numIterations; i ++) {
			int h = i * maxBits;
			if (i == numIterations - 1) {
				queenLocations[i] = Integer.parseUnsignedInt(s.substring(h), 2);
			} else {
				queenLocations[i] = Integer.parseUnsignedInt(s.substring(h,h+maxBits), 2);
			}
			queenLocations[i] = bitStreamToInt(s, h, h+maxBits);
		}
		return new NQueensState(queenLocations);
	}
	
	private int bitStreamToInt(int[] s, int start, int end) {
		
	}
	
	public boolean isAcceptableBitStream(int[] s) {
		if (alwaysAcceptableBitStream) {
			return true;
		}
		int maxBits = Integer.toBinaryString(n-1).length();
		int numIterations = s.length/maxBits; 
		for (int i = 0; i < numIterations; i ++) {
			int h = i * maxBits;
			if (i == numIterations - 1) {
				if (Integer.parseUnsignedInt(s.substring(h), 2) >= n) return false;
			} else {
				if (Integer.parseUnsignedInt(s.substring(h,h+maxBits), 2) >= n) return false;
			}
		}
		return true;
	}
	
	private int n;
	private boolean alwaysAcceptableBitStream;

}
